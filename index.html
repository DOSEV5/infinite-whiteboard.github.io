<!DOCTYPE html>
<html lang="bg">
<head>
<meta charset="UTF-8">
<title>–ë–µ–∑–∫—Ä–∞–π–Ω–∞ –ß–µ—Ä–Ω–∞ –î—ä—Å–∫–∞</title>
<style>
html, body {
  margin: 0; height: 100%; overflow: hidden; background: black;
}
canvas { display: block; width: 100%; height: 100%; cursor: crosshair; }

/* Toolbar */
#toolbar {
  position: fixed; top: 15px; left: 50%;
  transform: translateX(-50%);
  display: flex; gap: 12px; align-items: center;
  padding: 10px 18px; background: rgba(25,25,25,0.6);
  border-radius: 16px; backdrop-filter: blur(10px);
  box-shadow: 0 4px 20px rgba(0,0,0,0.4);
  font-family: sans-serif; z-index: 1000;
  transition: transform 0.3s ease, opacity 0.3s ease;
}
#toolbar.hidden { transform: translateX(-50%) translateY(-120px); opacity: 0; pointer-events: none; }

/* Buttons */
.btn {
  width: 36px; height: 36px; border: none; border-radius: 50%;
  background: rgba(255,255,255,0.1); color: white;
  font-size: 18px; display: flex; align-items: center; justify-content: center;
  cursor: pointer; transition: background 0.2s, transform 0.1s;
}
.btn:hover { background: rgba(255,255,255,0.25); transform: scale(1.05); }
.btn:active { transform: scale(0.95); }

/* Color palettes */
.color-picker, .bg-picker { display: flex; gap: 6px; margin: 0 10px; }
.color, .bg-btn { width: 22px; height: 22px; border-radius: 50%; border: 2px solid white; cursor: pointer; transition: transform 0.2s, border 0.2s; }
.color:hover, .bg-btn:hover { transform: scale(1.2); }
.bg-btn.active { border: 3px solid yellow; }

/* Brush size slider */
.slider { appearance: none; width: 100px; height: 6px; border-radius: 4px; background: #555; outline: none; cursor: pointer; }
.slider::-webkit-slider-thumb { width: 16px; height: 16px; border-radius: 50%; background: #fff; cursor: pointer; box-shadow: 0 0 4px rgba(0,0,0,0.5); }
.slider::-moz-range-thumb { width: 16px; height: 16px; border-radius: 50%; background: #fff; cursor: pointer; box-shadow: 0 0 4px rgba(0,0,0,0.5); }

/* Custom Erase Confirmation */
#confirmPopup { position: fixed; top:50%; left:50%; transform: translate(-50%, -50%) scale(0.7);
  background: rgba(30,30,30,0.95); color:white; padding: 20px 30px; border-radius:16px;
  font-family:sans-serif; font-size:16px; opacity:0; pointer-events:none; text-align:center;
  transition: all 0.3s ease; z-index:2000; box-shadow:0 0 20px rgba(0,0,0,0.5);
}
#confirmPopup.show { opacity:1; pointer-events:auto; transform:translate(-50%,-50%) scale(1); }
.confirm-buttons { margin-top:15px; display:flex; justify-content:center; gap:12px; }
.confirm-buttons button { background:#444; color:white; border:none; padding:6px 14px; border-radius:8px; cursor:pointer; font-size:14px; transition:all 0.2s ease; }
.confirm-buttons button:hover { background:#666; }

/* Brush/Eraser Preview */
#brushPreview { position:fixed; pointer-events:none; border-radius:50%; border:2px solid white; transform:translate(-50%,-50%); z-index:1002; }
</style>
</head>
<body>

<!-- Toolbar -->
<div id="toolbar">
  <button id="undo" class="btn">‚§∫</button>
  <button id="redo" class="btn">‚§ª</button>
  <button id="clear" class="btn">üóë</button>
  <button id="export" class="btn">üíæ</button>

  <div class="color-picker">
    <div class="color" data-color="#ffffff" style="background:#fff"></div>
    <div class="color" data-color="#ff0000" style="background:#f00"></div>
    <div class="color" data-color="#00ff00" style="background:#0f0"></div>
    <div class="color" data-color="#0000ff" style="background:#00f"></div>
    <div class="color" data-color="#ffff00" style="background:#ff0"></div>
    <div class="color" data-color="#ff00ff" style="background:#f0f"></div>
    <div class="color" data-color="#ff8000" style="background:#f80"></div>
  </div>

  <input type="range" id="size" class="slider" min="1" max="20" value="2">

  <button id="drawMode" class="btn">‚úèÔ∏è</button>
  <button id="eraser" class="btn">ü©π</button>

  <div class="bg-picker">
    <div class="bg-btn" data-bg="#000000" style="background:#000;"></div>
    <div class="bg-btn" data-bg="#ffffff" style="background:#fff;"></div>
    <div class="bg-btn active" data-bg="#171616" style="background:#171616;"></div>
  </div>
</div>

<canvas id="canvas"></canvas>

<!-- Custom Erase Confirmation -->
<div id="confirmPopup">
  <div class="confirm-text">–î–∞ –∏–∑—Ç—Ä–∏–µ–º –≤—Å–∏—á–∫–æ?</div>
  <div class="confirm-buttons">
    <button id="confirmYes">–î–∞</button>
    <button id="confirmNo">–ù–µ</button>
  </div>
</div>

<!-- Toolbar toggle button -->
<button id="toggleToolbar" class="btn" style="position:fixed; top:15px; right:15px; z-index:1001;">üëÅ</button>

<!-- Brush Preview -->
<div id="brushPreview"></div>

<script>
const canvas=document.getElementById("canvas"), ctx=canvas.getContext("2d");
let width=window.innerWidth, height=window.innerHeight; canvas.width=width; canvas.height=height;

let strokes=[], currentStroke=null;
let undoStack=[], redoStack=[];
let isDrawing=false, isPanning=false;
let lastMouse={x:0,y:0};
let currentColor="#ffffff";
let currentSize=parseInt(document.getElementById("size").value);
let mode="draw";
let bgColor="#171616";

const undoBtn=document.getElementById("undo");
const redoBtn=document.getElementById("redo");
const clearBtn=document.getElementById("clear");
const exportBtn=document.getElementById("export");
const drawModeBtn=document.getElementById("drawMode");
const eraserBtn=document.getElementById("eraser");
const sizeSlider=document.getElementById("size");
const colorCircles=document.querySelectorAll(".color");
const bgButtons=document.querySelectorAll(".bg-btn");
const brushPreview=document.getElementById("brushPreview");

let scale=1, offsetX=0, offsetY=0;
function screenToWorld(x,y){return {x:(x-offsetX)/scale, y:(y-offsetY)/scale};}

// Redraw
function redraw(){
  ctx.setTransform(1,0,0,1,0,0); ctx.fillStyle=bgColor; ctx.fillRect(0,0,width,height);
  ctx.setTransform(scale,0,0,scale,offsetX,offsetY); ctx.lineCap="round"; ctx.lineJoin="round";
  for(const s of strokes){
    ctx.strokeStyle=s.color; ctx.lineWidth=s.width;
    ctx.beginPath(); ctx.moveTo(s.points[0].x,s.points[0].y);
    for(let i=1;i<s.points.length;i++) ctx.lineTo(s.points[i].x,s.points[i].y);
    ctx.stroke();
  }
}

// Brush preview
function updateBrushPreview(){
  brushPreview.style.width=currentSize+"px";
  brushPreview.style.height=currentSize+"px";
  brushPreview.style.borderColor=(mode==="erase"?"white":currentColor);
}
document.addEventListener("mousemove", e=>{
  brushPreview.style.left=e.clientX+"px";
  brushPreview.style.top=e.clientY+"px";
});

// Color picker
colorCircles.forEach(c=>c.addEventListener("click",()=>{ currentColor=c.dataset.color; updateBrushPreview(); }));
sizeSlider.oninput=()=>{ currentSize=parseInt(sizeSlider.value); updateBrushPreview(); };
bgButtons.forEach(b=>{ b.addEventListener("click",()=>{
  bgColor=b.dataset.bg; bgButtons.forEach(btn=>btn.classList.remove("active")); b.classList.add("active"); redraw();
})});
drawModeBtn.onclick=()=>{ mode="draw"; updateBrushPreview(); };
eraserBtn.onclick=()=>{ mode="erase"; updateBrushPreview(); };

// Mouse
canvas.addEventListener("mousedown", e=>{
  if(e.button===1||e.shiftKey){ isPanning=true; lastMouse={x:e.clientX,y:e.clientY}; return; }
  if(e.button===0){
    isDrawing=true; const world=screenToWorld(e.clientX,e.clientY);
    currentStroke={points:[world], width:currentSize/scale, color:currentColor};
    strokes.push(currentStroke);
    redraw();
  }
});
canvas.addEventListener("mousemove", e=>{
  if(isPanning){ offsetX+=e.clientX-lastMouse.x; offsetY+=e.clientY-lastMouse.y; lastMouse={x:e.clientX,y:e.clientY}; redraw(); return; }
  if(isDrawing){
    const world=screenToWorld(e.clientX,e.clientY);
    if(mode==="draw"){ currentStroke.points.push(world); }
    else if(mode==="erase"){ eraseAt(world, currentSize/scale); }
    redraw();
  }
});
canvas.addEventListener("mouseup", e=>{
  if(isPanning){ isPanning=false; return; }
  if(isDrawing){ isDrawing=false;
    undoStack.push({ undo:()=>{ strokes.pop(); redraw(); }, redo:()=>{ strokes.push(currentStroke); redraw(); } });
    redoStack.length=0;
  }
});
canvas.addEventListener("wheel", e=>{
  e.preventDefault();
  const mouse={x:e.clientX,y:e.clientY};
  const worldBefore=screenToWorld(mouse.x, mouse.y);
  const factor=e.deltaY<0?1.1:1/1.1;
  scale*=factor; scale=Math.min(Math.max(scale,0.05),50);
  const worldAfter=screenToWorld(mouse.x, mouse.y);
  offsetX+=(worldAfter.x-worldBefore.x)*scale;
  offsetY+=(worldAfter.y-worldBefore.y)*scale;
  redraw();
},{passive:false});
window.addEventListener("resize", ()=>{ width=window.innerWidth; height=window.innerHeight; canvas.width=width; canvas.height=height; redraw(); });

// Undo/Redo
function undo(){ if(undoStack.length>0){ const cmd=undoStack.pop(); cmd.undo(); redoStack.push(cmd); } }
function redo(){ if(redoStack.length>0){ const cmd=redoStack.pop(); cmd.redo(); undoStack.push(cmd); } }
undoBtn.onclick=undo; redoBtn.onclick=redo;
window.addEventListener("keydown", e=>{ if(e.ctrlKey && (e.key==="z"||e.key==="Z")){ e.preventDefault(); undo(); } });
function exportPNG(){ const img=canvas.toDataURL("image/png"); const a=document.createElement("a"); a.href=img; a.download="canvas.png"; a.click(); }
exportBtn.onclick=exportPNG;

// Clear
const confirmPopup=document.getElementById("confirmPopup");
const yesBtn=document.getElementById("confirmYes");
const noBtn=document.getElementById("confirmNo");
clearBtn.onclick=()=>{ confirmPopup.classList.add("show"); };
yesBtn.onclick=()=>{ strokes=[]; undoStack=[]; redoStack=[]; redraw(); confirmPopup.classList.remove("show"); };
noBtn.onclick=()=>{ confirmPopup.classList.remove("show"); };

// Toolbar toggle
const toggleBtn=document.getElementById("toggleToolbar");
const toolbar=document.getElementById("toolbar");
let toolbarVisible=true;
toggleBtn.onclick=()=>{ toolbarVisible=!toolbarVisible; toolbarVisible?toolbar.classList.remove("hidden"):toolbar.classList.add("hidden"); };

// --- Eraser logic ---
function eraseAt(point, radius){
  let newStrokes=[];
  for(const s of strokes){
    let segments=[], current=[];
    for(const p of s.points){
      const dx=p.x-point.x, dy=p.y-point.y;
      if(Math.sqrt(dx*dx+dy*dy)>radius){ current.push(p); }
      else{ if(current.length>0){ segments.push(current); current=[]; } }
    }
    if(current.length>0) segments.push(current);
    for(const seg of segments){ if(seg.length>0) newStrokes.push({points:seg, width:s.width, color:s.color}); }
  }
  strokes=newStrokes;
}
updateBrushPreview();
redraw();
</script>
</body>
</html>
