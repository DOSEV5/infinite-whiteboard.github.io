<!DOCTYPE html>
<html lang="bg">
<head>
<meta charset="UTF-8">
<title>–ë–µ–∑–∫—Ä–∞–π–Ω–∞ –ß–µ—Ä–Ω–∞ –î—ä—Å–∫–∞</title>
<style>
html, body {
  margin: 0; padding: 0; height: 100%; overflow: hidden; background: black;
}
canvas { display: block; width: 100%; height: 100%; cursor: crosshair; }

/* Toolbar */
#toolbar {
  position: fixed; top: 15px; left: 50%;
  transform: translateX(-50%);
  display: flex; gap: 12px; align-items: center;
  padding: 10px 18px; background: rgba(25,25,25,0.6);
  border-radius: 16px; backdrop-filter: blur(10px);
  box-shadow: 0 4px 20px rgba(0,0,0,0.4);
  font-family: sans-serif; z-index: 1000;
  transition: transform 0.3s ease, opacity 0.3s ease;
}
#toolbar.hidden { transform: translateX(-50%) translateY(-120px); opacity: 0; pointer-events: none; }

/* Buttons */
.btn {
  width: 36px; height: 36px; border: none; border-radius: 50%;
  background: rgba(255,255,255,0.1); color: white;
  font-size: 18px; display: flex; align-items: center; justify-content: center;
  cursor: pointer; transition: background 0.2s, transform 0.1s;
}
.btn:hover { background: rgba(255,255,255,0.25); transform: scale(1.05); }
.btn:active { transform: scale(0.95); }

/* Color palettes */
.color-picker, .bg-picker { display: flex; gap: 4px; margin: 0 10px; align-items: center; }
.color, .bg-btn { 
  width: 20px; height: 20px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.3); 
  cursor: pointer; transition: transform 0.2s, border 0.2s, box-shadow 0.2s; 
}
.color:hover, .bg-btn:hover { 
  transform: scale(1.1); 
  border: 1px solid rgba(255,255,255,0.8);
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}
.color.active { 
  border: 2px solid white; 
  box-shadow: 0 0 0 1px rgba(0,0,0,0.5);
}
.bg-btn.active { border: 2px solid yellow; }

/* Custom Color Picker Wrapper */
.custom-color-wrapper {
  position: relative;
  display: flex;
  align-items: center;
}
#customColorBtn { 
  width: 32px; height: 32px; border-radius: 50%; 
  border: 2px solid rgba(255,255,255,0.5);
  cursor: pointer; position: relative; overflow: hidden;
  transition: transform 0.2s, border 0.2s, box-shadow 0.2s;
  background: conic-gradient(
    red, yellow, lime, aqua, blue, magenta, red
  );
  box-shadow: 0 2px 8px rgba(0,0,0,0.3), inset 0 0 0 2px rgba(0,0,0,0.3);
}
#customColorBtn:hover { 
  transform: scale(1.1); 
  border: 2px solid rgba(255,255,255,0.9);
  box-shadow: 0 4px 12px rgba(0,0,0,0.4), inset 0 0 0 2px rgba(0,0,0,0.3);
}
#customColorBtn::after {
  content: 'üé®';
  position: absolute;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  font-size: 16px;
  text-shadow: 0 0 3px rgba(0,0,0,0.8);
}
#customColor { 
  position: absolute;
  opacity: 0;
  width: 0;
  height: 0;
  pointer-events: none;
}

/* Brush size slider */
.slider { appearance: none; width: 100px; height: 6px; border-radius: 4px; background: #555; outline: none; cursor: pointer; }
.slider::-webkit-slider-thumb { width: 16px; height: 16px; border-radius: 50%; background: #fff; cursor: pointer; box-shadow: 0 0 4px rgba(0,0,0,0.5); }
.slider::-moz-range-thumb { width: 16px; height: 16px; border-radius: 50%; background: #fff; cursor: pointer; box-shadow: 0 0 4px rgba(0,0,0,0.5); }

/* Custom Erase Confirmation */
#confirmPopup { position: fixed; top:50%; left:50%; transform: translate(-50%, -50%) scale(0.7);
  background: rgba(30,30,30,0.95); color:white; padding: 20px 30px; border-radius:16px;
  font-family:sans-serif; font-size:16px; opacity:0; pointer-events:none; text-align:center;
  transition: all 0.3s ease; z-index:2000; box-shadow:0 0 20px rgba(0,0,0,0.5);
}
#confirmPopup.show { opacity:1; pointer-events:auto; transform:translate(-50%,-50%) scale(1); }
.confirm-buttons { margin-top:15px; display:flex; justify-content:center; gap:12px; }
.confirm-buttons button { background:#444; color:white; border:none; padding:6px 14px; border-radius:8px; cursor:pointer; font-size:14px; transition:all 0.2s ease; }
.confirm-buttons button:hover { background:#666; }

/* Brush/Eraser Preview */
#brushPreview { position:fixed; pointer-events:none; border-radius:50%; border:2px solid white; transform:translate(-50%,-50%); z-index:1002; }
.mode-active { background: rgba(255,255,255,0.3) !important; }

/* Tool indicator */
#toolIndicator {
  position: fixed; bottom: 20px; left: 20px;
  background: rgba(25,25,25,0.8); color: white;
  padding: 8px 16px; border-radius: 20px;
  font-family: sans-serif; font-size: 14px;
  backdrop-filter: blur(10px);
  box-shadow: 0 2px 10px rgba(0,0,0,0.3);
  z-index: 1000;
  display: flex; align-items: center; gap: 8px;
}

/* Save indicator */
#saveIndicator {
  position: fixed; bottom: 20px; right: 20px;
  background: rgba(76, 175, 80, 0.9); color: white;
  padding: 8px 16px; border-radius: 20px;
  font-family: sans-serif; font-size: 12px;
  backdrop-filter: blur(10px);
  box-shadow: 0 2px 10px rgba(0,0,0,0.3);
  z-index: 1000;
  opacity: 0;
  transition: opacity 0.3s ease;
}
#saveIndicator.show { opacity: 1; }

/* How to use popup */
#howToUsePopup {
  position: fixed; top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.8); color: white;
  display: flex; align-items: center; justify-content: center;
  font-family: sans-serif; z-index: 3000;
  opacity: 1; transition: opacity 0.3s ease;
}
#howToUsePopup.hidden { opacity: 0; pointer-events: none; display: none; }

/* Export popup */
#exportPopup {
  position: fixed; top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.8); color: white;
  display: none; align-items: center; justify-content: center;
  font-family: sans-serif; z-index: 3000;
}

.export-content {
  background: rgba(30,30,30,0.95); padding: 30px; border-radius: 16px;
  max-width: 400px; text-align: center; line-height: 1.6;
  box-shadow: 0 8px 32px rgba(0,0,0,0.6);
}
.export-content h2 { margin-top: 0; color: #4CAF50; }

.export-options {
  display: grid; grid-template-columns: 1fr 1fr; gap: 12px;
  margin: 20px 0;
}
.export-btn {
  background: rgba(76, 175, 80, 0.2); border: 1px solid #4CAF50;
  color: white; padding: 12px 16px; border-radius: 8px;
  cursor: pointer; transition: all 0.2s; font-size: 14px;
}
.export-btn:hover { background: rgba(76, 175, 80, 0.3); transform: scale(1.02); }

.export-actions {
  display: flex; justify-content: center; gap: 12px; margin-top: 20px;
}
.export-actions button {
  background: #444; color: white; border: none;
  padding: 8px 16px; border-radius: 8px; cursor: pointer;
  font-size: 14px; transition: all 0.2s;
}
.export-actions button:hover { background: #666; }
.export-actions button.primary { background: #4CAF50; }
.export-actions button.primary:hover { background: #45a049; }

.how-to-content {
  background: rgba(30,30,30,0.95); padding: 30px; border-radius: 16px;
  max-width: 500px; text-align: left; line-height: 1.6;
  box-shadow: 0 8px 32px rgba(0,0,0,0.6);
}
.how-to-content h2 { margin-top: 0; color: #4CAF50; text-align: center; }
.how-to-content ul { padding-left: 20px; }
.how-to-content li { margin: 8px 0; }
.how-to-content .close-btn {
  background: #4CAF50; color: white; border: none;
  padding: 10px 20px; border-radius: 8px; cursor: pointer;
  font-size: 14px; display: block; margin: 20px auto 0;
  transition: background 0.2s;
}
.how-to-content .close-btn:hover { background: #45a049; }
</style>
</head>
<body>

<!-- Toolbar -->
<div id="toolbar">
  <button id="undo" class="btn">‚§∫</button>
  <button id="redo" class="btn">‚§ª</button>
  <button id="clear" class="btn">üóë</button>
  <button id="clearStorage" class="btn" title="–ò–∑—Ç—Ä–∏–π –∑–∞–ø–∞–∑–µ–Ω–∞—Ç–∞ —Ä–∏—Å—É–Ω–∫–∞">üí£</button>
  <button id="export" class="btn">üíæ</button>
  <button id="gridToggle" class="btn" title="–ü–æ–∫–∞–∂–∏/—Å–∫—Ä–∏–π –º—Ä–µ–∂–∞—Ç–∞">üìê</button>

  <div class="color-picker">
    <div class="color" data-color="#000000" style="background:#000"></div>
    <div class="color" data-color="#404040" style="background:#404040"></div>
    <div class="color" data-color="#ffffff" style="background:#fff"></div>
    <div class="color" data-color="#ff0000" style="background:#f00"></div>
    <div class="color" data-color="#ff6600" style="background:#ff6600"></div>
    <div class="color" data-color="#ffcc00" style="background:#ffcc00"></div>
    <div class="color" data-color="#00ff00" style="background:#0f0"></div>
    <div class="color" data-color="#0080ff" style="background:#0080ff"></div>
    <div class="color" data-color="#0000ff" style="background:#00f"></div>
    <div class="color" data-color="#8000ff" style="background:#8000ff"></div>
    <div class="custom-color-wrapper">
      <div id="customColorBtn"></div>
      <input type="color" id="customColor" value="#ffffff">
    </div>
  </div>

  <input type="range" id="size" class="slider" min="1" max="20" value="2">

  <button id="drawMode" class="btn mode-active">‚úèÔ∏è</button>
  <button id="eraser" class="btn">ü©π</button>

  <div class="bg-picker">
    <div class="bg-btn" data-bg="#000000" style="background:#000;"></div>
    <div class="bg-btn" data-bg="#ffffff" style="background:#fff;"></div>
    <div class="bg-btn active" data-bg="#171616" style="background:#171616;"></div>
  </div>
</div>

<canvas id="canvas"></canvas>

<!-- Custom Erase Confirmation -->
<div id="confirmPopup">
  <div class="confirm-text">–î–∞ –∏–∑—Ç—Ä–∏–µ–º –≤—Å–∏—á–∫–æ?</div>
  <div class="confirm-buttons">
    <button id="confirmYes">–î–∞</button>
    <button id="confirmNo">–ù–µ</button>
  </div>
</div>

<!-- Toolbar toggle button -->
<button id="toggleToolbar" class="btn" style="position:fixed; top:15px; right:15px; z-index:1001;">üëÅ</button>

<!-- Brush Preview -->
<div id="brushPreview"></div>

<!-- Tool Indicator -->
<div id="toolIndicator">
  <span id="toolIcon">‚úèÔ∏è</span>
  <span id="toolName">–ß–µ—Ç–∫–∞</span>
</div>

<!-- Save Indicator -->
<div id="saveIndicator">üíæ –ó–∞–ø–∞–∑–µ–Ω–æ!</div>

<!-- How to Use Popup -->
<div id="howToUsePopup">
  <div class="how-to-content">
    <h2>üé® –ö–∞–∫ –¥–∞ –∏–∑–ø–æ–ª–∑–≤–∞–º —á–µ—Ä–Ω–∞—Ç–∞ –¥—ä—Å–∫–∞?</h2>
    <ul>
      <li><strong>–†–∏—Å—É–≤–∞–Ω–µ:</strong> –ö–ª–∏–∫–Ω–∏ –∏ –≤–ª–∞—á–∏ —Å –º–∏—à–∫–∞—Ç–∞ –∑–∞ –¥–∞ —Ä–∏—Å—É–≤–∞—à</li>
      <li><strong>–ú–∞—â–∞–±–∏—Ä–∞–Ω–µ:</strong> –ò–∑–ø–æ–ª–∑–≤–∞–π –∫–æ–ª–µ–ª—Ü–µ—Ç–æ –Ω–∞ –º–∏—à–∫–∞—Ç–∞</li>
      <li><strong>–ü—Ä–µ–º–µ—Å—Ç–≤–∞–Ω–µ:</strong> –î—ä—Ä–∂–∏ Shift –∏–ª–∏ —Å—Ä–µ–¥–Ω–æ—Ç–æ –∫–æ–ø—á–µ –Ω–∞ –º–∏—à–∫–∞—Ç–∞</li>
      <li><strong>–¶–≤–µ—Ç–æ–≤–µ:</strong> –ò–∑–±–µ—Ä–∏ —Ü–≤—è—Ç –æ—Ç –ø–∞–ª–∏—Ç—Ä–∞—Ç–∞ –∏–ª–∏ –∏–∑–ø–æ–ª–∑–≤–∞–π —Ü–≤–µ—Ç–Ω–∏—è –∏–∑–±–∏—Ä–∞—Ç–µ–ª</li>
      <li><strong>–†–∞–∑–º–µ—Ä:</strong> –†–µ–≥—É–ª–∏—Ä–∞–π —Ä–∞–∑–º–µ—Ä–∞ –Ω–∞ —á–µ—Ç–∫–∞—Ç–∞ —Å—ä—Å —Å–ª–∞–π–¥—ä—Ä–∞</li>
      <li><strong>–ì—É–º–∞:</strong> –ù–∞—Ç–∏—Å–Ω–∏ –∏–∫–æ–Ω–∞—Ç–∞ ü©π –∑–∞ –¥–∞ –∏–∑—Ç—Ä–∏–≤–∞—à</li>
      <li><strong>–ù–∞–∑–∞–¥/–ù–∞–ø—Ä–µ–¥:</strong> Ctrl+Z –∑–∞ –Ω–∞–∑–∞–¥, Ctrl+Shift+Z –∑–∞ –Ω–∞–ø—Ä–µ–¥</li>
      <li><strong>–°–∫—Ä–∏–≤–∞–Ω–µ –Ω–∞ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∏:</strong> –ù–∞—Ç–∏—Å–Ω–∏ üëÅ –≤ –≥–æ—Ä–Ω–∏—è –¥–µ—Å–µ–Ω —ä–≥—ä–ª</li>
      <li><strong>–ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –∑–∞–ø–∞–∑–≤–∞–Ω–µ:</strong> –†–∏—Å—É–Ω–∫–∞—Ç–∞ —Å–µ –∑–∞–ø–∞–∑–≤–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –∏ —Å–µ –≤—ä–∑—Å—Ç–∞–Ω–æ–≤—è–≤–∞ –ø—Ä–∏ –ø—Ä–µ–∑–∞—Ä–µ–∂–¥–∞–Ω–µ!</li>
      <li><strong>–ò–∑—Ç—Ä–∏–≤–∞–Ω–µ –Ω–∞ –∑–∞–ø–∞–∑–µ–Ω–æ—Ç–æ:</strong> –ù–∞—Ç–∏—Å–Ω–∏ üí£ –∑–∞ –¥–∞ –∏–∑—Ç—Ä–∏–µ—à –∑–∞–ø–∞–∑–µ–Ω–∞—Ç–∞ —Ä–∏—Å—É–Ω–∫–∞</li>
    </ul>
    <button onclick="document.getElementById('howToUsePopup').style.display='none'" class="close-btn">–†–∞–∑–±—Ä–∞—Ö, –∑–∞–ø–æ—á–≤–∞–º!</button>
  </div>
</div>

<!-- Export Popup -->
<div id="exportPopup">
  <div class="export-content">
    <h2>üíæ –ï–∫—Å–ø–æ—Ä—Ç–∏—Ä–∞–π —Ä–∏—Å—É–Ω–∫–∞—Ç–∞</h2>
    
    <div class="export-options">
      <button class="export-btn" onclick="exportDrawing('png')">PNG –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ</button>
      <button class="export-btn" onclick="exportDrawing('jpg')">JPG –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ</button>
      <button class="export-btn" onclick="exportDrawing('svg')">SVG –≤–µ–∫—Ç–æ—Ä</button>
      <button class="export-btn" onclick="exportDrawing('pdf')">PDF –¥–æ–∫—É–º–µ–Ω—Ç</button>
    </div>

    <div class="export-actions">
      <button onclick="document.getElementById('exportPopup').style.display='none'">–û—Ç–∫–∞–∑</button>
    </div>
  </div>
</div>

<script>
const canvas=document.getElementById("canvas"), ctx=canvas.getContext("2d");
let width=window.innerWidth, height=window.innerHeight; 

// Infinite canvas with tiling system
const TILE_SIZE = 2000;
canvas.width=width; 
canvas.height=height;

let strokes=[], currentStroke=null;
let undoStack=[], redoStack=[];
let isDrawing=false, isPanning=false;
let lastMouse={x:0,y:0};
let currentColor="#ffffff";
let currentSize=parseInt(document.getElementById("size").value);
let mode="draw";
let bgColor="#171616";

const undoBtn=document.getElementById("undo");
const redoBtn=document.getElementById("redo");
const clearBtn=document.getElementById("clear");
const clearStorageBtn=document.getElementById("clearStorage");
const exportBtn=document.getElementById("export");
const gridToggleBtn=document.getElementById("gridToggle");
const drawModeBtn=document.getElementById("drawMode");
const eraserBtn=document.getElementById("eraser");
const sizeSlider=document.getElementById("size");
const colorCircles=document.querySelectorAll(".color");
const customColorPicker=document.getElementById("customColor");
const customColorBtn=document.getElementById("customColorBtn");
const bgButtons=document.querySelectorAll(".bg-btn");
const brushPreview=document.getElementById("brushPreview");
const toolIndicator=document.getElementById("toolIndicator");
const toolIcon=document.getElementById("toolIcon");
const toolName=document.getElementById("toolName");
const saveIndicator=document.getElementById("saveIndicator");
const howToUsePopup=document.getElementById("howToUsePopup");
const exportPopup=document.getElementById("exportPopup");

let scale=1, offsetX=0, offsetY=0;
let showGrid=true;
function screenToWorld(x,y){return {x:(x-offsetX)/scale, y:(y-offsetY)/scale};}

// ============= LOCAL STORAGE FUNCTIONS =============

function saveToLocalStorage() {
  try {
    const data = {
      strokes: strokes,
      bgColor: bgColor,
      scale: scale,
      offsetX: offsetX,
      offsetY: offsetY,
      currentColor: currentColor,
      currentSize: currentSize,
      showGrid: showGrid,
      timestamp: Date.now()
    };
    localStorage.setItem('blackboard_drawing', JSON.stringify(data));
    
    // Show save indicator
    saveIndicator.classList.add('show');
    setTimeout(() => {
      saveIndicator.classList.remove('show');
    }, 1500);
  } catch(e) {
    console.error('Failed to save to localStorage:', e);
  }
}

function loadFromLocalStorage() {
  try {
    const saved = localStorage.getItem('blackboard_drawing');
    if(saved) {
      const data = JSON.parse(saved);
      strokes = data.strokes || [];
      bgColor = data.bgColor || "#171616";
      scale = data.scale || 1;
      offsetX = data.offsetX || 0;
      offsetY = data.offsetY || 0;
      currentColor = data.currentColor || "#ffffff";
      currentSize = data.currentSize || 2;
      showGrid = data.showGrid !== undefined ? data.showGrid : true;
      
      // Update UI
      sizeSlider.value = currentSize;
      customColorPicker.value = currentColor;
      
      // Update active background button
      bgButtons.forEach(btn => {
        btn.classList.toggle('active', btn.dataset.bg === bgColor);
      });
      
      console.log('Drawing loaded from localStorage');
      return true;
    }
  } catch(e) {
    console.error('Failed to load from localStorage:', e);
  }
  return false;
}

function clearLocalStorage() {
  if(confirm('–°–∏–≥—É—Ä–Ω–∏ –ª–∏ —Å—Ç–µ, —á–µ –∏—Å–∫–∞—Ç–µ –¥–∞ –∏–∑—Ç—Ä–∏–µ—Ç–µ –∑–∞–ø–∞–∑–µ–Ω–∞—Ç–∞ —Ä–∏—Å—É–Ω–∫–∞ –æ—Ç –ø–∞–º–µ—Ç—Ç–∞? –¢–æ–≤–∞ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ –º–æ–∂–µ –¥–∞ –±—ä–¥–µ –æ—Ç–º–µ–Ω–µ–Ω–æ!')) {
    localStorage.removeItem('blackboard_drawing');
    alert('–ó–∞–ø–∞–∑–µ–Ω–∞—Ç–∞ —Ä–∏—Å—É–Ω–∫–∞ –µ –∏–∑—Ç—Ä–∏—Ç–∞ –æ—Ç –ø–∞–º–µ—Ç—Ç–∞! –¢–µ–∫—É—â–∞—Ç–∞ —Ä–∏—Å—É–Ω–∫–∞ –æ—Å—Ç–∞–≤–∞ –Ω–∞ –µ–∫—Ä–∞–Ω–∞.');
  }
}

// Auto-save with debounce
let saveTimeout;
function autoSave() {
  clearTimeout(saveTimeout);
  saveTimeout = setTimeout(() => {
    saveToLocalStorage();
  }, 1000); // Save 1 second after last action
}

// ============= EXPORT FUNCTIONS =============

function exportDrawing(format) {
  const exportWidth = canvas.width;
  const exportHeight = canvas.height;

  if (format === 'svg') {
    exportSVG(exportWidth, exportHeight);
  } else if (format === 'pdf') {
    exportPDF(exportWidth, exportHeight);
  } else {
    exportRaster(format, exportWidth, exportHeight);
  }
  
  document.getElementById('exportPopup').style.display = 'none';
}

function exportRaster(format, width, height) {
  const tempCanvas = document.createElement('canvas');
  const tempCtx = tempCanvas.getContext('2d');
  tempCanvas.width = width;
  tempCanvas.height = height;

  tempCtx.fillStyle = bgColor;
  tempCtx.fillRect(0, 0, width, height);

  const bounds = getDrawingBounds();
  if (bounds) {
    const scaleX = width / (bounds.maxX - bounds.minX + 100);
    const scaleY = height / (bounds.maxY - bounds.minY + 100);
    const drawScale = Math.min(scaleX, scaleY, 1);
    
    tempCtx.translate(width/2, height/2);
    tempCtx.scale(drawScale, drawScale);
    tempCtx.translate(-(bounds.minX + bounds.maxX)/2, -(bounds.minY + bounds.maxY)/2);
  }

  tempCtx.lineCap = "round";
  tempCtx.lineJoin = "round";
  
  for(const s of strokes) {
    if(s.isEraser) {
      tempCtx.strokeStyle = bgColor;
      tempCtx.fillStyle = bgColor;
    } else {
      tempCtx.strokeStyle = s.color;
      tempCtx.fillStyle = s.color;
    }
    
    tempCtx.lineWidth = s.width;
    if(s.points.length > 1) {
      tempCtx.beginPath();
      tempCtx.moveTo(s.points[0].x, s.points[0].y);
      for(let i = 1; i < s.points.length; i++) {
        tempCtx.lineTo(s.points[i].x, s.points[i].y);
      }
      tempCtx.stroke();
    } else if(s.points.length === 1) {
      tempCtx.beginPath();
      tempCtx.arc(s.points[0].x, s.points[0].y, s.width/2, 0, Math.PI * 2);
      tempCtx.fill();
    }
  }

  const mimeType = format === 'jpg' ? 'image/jpeg' : 'image/png';
  const img = tempCanvas.toDataURL(mimeType, 0.9);
  const a = document.createElement('a');
  a.href = img;
  a.download = `drawing.${format}`;
  a.click();
}

function exportSVG(width, height) {
  const bounds = getDrawingBounds();
  const svgWidth = bounds ? (bounds.maxX - bounds.minX + 100) : width;
  const svgHeight = bounds ? (bounds.maxY - bounds.minY + 100) : height;
  const offsetX = bounds ? bounds.minX - 50 : 0;
  const offsetY = bounds ? bounds.minY - 50 : 0;

  let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="${offsetX} ${offsetY} ${svgWidth} ${svgHeight}">`;
  svg += `<rect width="100%" height="100%" fill="${bgColor}"/>`;
  
  for(const s of strokes) {
    if(s.points.length > 1 && !s.isEraser) {
      const pathData = `M${s.points[0].x},${s.points[0].y} ` + 
                      s.points.slice(1).map(p => `L${p.x},${p.y}`).join(' ');
      svg += `<path d="${pathData}" stroke="${s.color}" stroke-width="${s.width}" fill="none" stroke-linecap="round" stroke-linejoin="round"/>`;
    } else if(s.points.length === 1 && !s.isEraser) {
      svg += `<circle cx="${s.points[0].x}" cy="${s.points[0].y}" r="${s.width/2}" fill="${s.color}"/>`;
    }
  }
  
  svg += '</svg>';
  
  const blob = new Blob([svg], {type: 'image/svg+xml'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'drawing.svg';
  a.click();
  URL.revokeObjectURL(url);
}

function exportPDF(width, height) {
  exportRaster('png', width, height);
  alert('PDF export –∫–∞—Ç–æ PNG. –ó–∞ –∏—Å—Ç–∏–Ω—Å–∫–∏ PDF, –º–æ–ª—è –∏–∑–ø–æ–ª–∑–≤–∞–π—Ç–µ –æ–Ω–ª–∞–π–Ω –∫–æ–Ω–≤–µ—Ä—Ç–æ—Ä.');
}

function getDrawingBounds() {
  if(strokes.length === 0) return null;
  
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  
  for(const s of strokes) {
    for(const p of s.points) {
      minX = Math.min(minX, p.x - s.width/2);
      minY = Math.min(minY, p.y - s.width/2);
      maxX = Math.max(maxX, p.x + s.width/2);
      maxY = Math.max(maxY, p.y + s.width/2);
    }
  }
  
  return {minX, minY, maxX, maxY};
}

// ============= DRAWING FUNCTIONS =============

function redraw(){
  // Clear and fill background
  ctx.setTransform(1,0,0,1,0,0); 
  ctx.fillStyle=bgColor; 
  ctx.fillRect(0,0,width,height);
  
  // Create an offscreen canvas for drawing (without grid)
  const offCanvas = document.createElement('canvas');
  offCanvas.width = width;
  offCanvas.height = height;
  const offCtx = offCanvas.getContext('2d');
  
  // Fill offscreen canvas with background
  offCtx.fillStyle = bgColor;
  offCtx.fillRect(0, 0, width, height);
  
  // Set transformation for drawing on offscreen canvas
  offCtx.setTransform(scale,0,0,scale,offsetX,offsetY);
  offCtx.lineCap="round"; 
  offCtx.lineJoin="round";
  
  // Draw all strokes on offscreen canvas
  for(const s of strokes){
    if(s.isEraser) {
      // Use destination-out to actually erase pixels
      offCtx.globalCompositeOperation = "destination-out";
      offCtx.strokeStyle = "rgba(0,0,0,1)";
      offCtx.fillStyle = "rgba(0,0,0,1)";
    } else {
      offCtx.globalCompositeOperation = "source-over";
      offCtx.strokeStyle = s.color;
      offCtx.fillStyle = s.color;
    }
    
    offCtx.lineWidth=s.width;
    if(s.points.length > 1) {
      offCtx.beginPath(); 
      offCtx.moveTo(s.points[0].x,s.points[0].y);
      for(let i=1;i<s.points.length;i++) {
        offCtx.lineTo(s.points[i].x,s.points[i].y);
      }
      offCtx.stroke();
    } else if(s.points.length === 1) {
      offCtx.beginPath();
      offCtx.arc(s.points[0].x, s.points[0].y, s.width/2, 0, Math.PI * 2);
      offCtx.fill();
    }
  }
  
  // Draw the offscreen canvas onto main canvas
  ctx.setTransform(1,0,0,1,0,0);
  ctx.drawImage(offCanvas, 0, 0);
  
  // Now draw grid on top
  ctx.setTransform(scale,0,0,scale,offsetX,offsetY);
  
  if(showGrid) {
    ctx.strokeStyle = "rgba(255,255,255,0.05)";
    ctx.lineWidth = 1/scale;
    
    const worldTL = screenToWorld(0, 0);
    const worldBR = screenToWorld(width, height);
    
    const startX = Math.floor(worldTL.x / TILE_SIZE) * TILE_SIZE;
    const startY = Math.floor(worldTL.y / TILE_SIZE) * TILE_SIZE;
    const endX = Math.ceil(worldBR.x / TILE_SIZE) * TILE_SIZE;
    const endY = Math.ceil(worldBR.y / TILE_SIZE) * TILE_SIZE;
    
    for(let x = startX; x <= endX; x += TILE_SIZE) {
      ctx.beginPath();
      ctx.moveTo(x, startY);
      ctx.lineTo(x, endY);
      ctx.stroke();
    }
    
    for(let y = startY; y <= endY; y += TILE_SIZE) {
      ctx.beginPath();
      ctx.moveTo(startX, y);
      ctx.lineTo(endX, y);
      ctx.stroke();
    }
  }
}

// Brush preview
function updateBrushPreview(){
  brushPreview.style.width=currentSize+"px";
  brushPreview.style.height=currentSize+"px";
  brushPreview.style.borderColor=(mode==="erase"?"red":currentColor);
  brushPreview.style.borderStyle=(mode==="erase"?"dashed":"solid");
}

function updateModeButtons() {
  drawModeBtn.classList.toggle("mode-active", mode === "draw");
  eraserBtn.classList.toggle("mode-active", mode === "erase");
  gridToggleBtn.classList.toggle("mode-active", showGrid);
  
  if(mode === "draw") {
    toolIcon.textContent = "‚úèÔ∏è";
    toolName.textContent = "–ß–µ—Ç–∫–∞";
  } else {
    toolIcon.textContent = "ü©π";
    toolName.textContent = "–ì—É–º–∞";
  }
}

document.addEventListener("mousemove", e=>{
  brushPreview.style.left=e.clientX+"px";
  brushPreview.style.top=e.clientY+"px";
});

// ============= EVENT HANDLERS =============

// Color picker
colorCircles.forEach(c=>c.addEventListener("click",()=>{ 
  colorCircles.forEach(color => color.classList.remove("active"));
  c.classList.add("active");
  currentColor=c.dataset.color; 
  customColorPicker.value = currentColor;
  updateBrushPreview(); 
  autoSave();
}));

// Custom color picker
customColorBtn.addEventListener("click", ()=>{
  customColorPicker.click();
});

customColorPicker.addEventListener("input", ()=>{
  currentColor = customColorPicker.value;
  colorCircles.forEach(color => color.classList.remove("active"));
  customColorBtn.style.background = currentColor;
  updateBrushPreview();
});

customColorPicker.addEventListener("change", ()=>{
  currentColor = customColorPicker.value;
  colorCircles.forEach(color => color.classList.remove("active"));
  customColorBtn.style.background = currentColor;
  updateBrushPreview();
  autoSave();
});

sizeSlider.oninput=()=>{ 
  currentSize=parseInt(sizeSlider.value); 
  updateBrushPreview(); 
  autoSave();
};

bgButtons.forEach(b=>{ 
  b.addEventListener("click",()=>{
    bgColor=b.dataset.bg; 
    bgButtons.forEach(btn=>btn.classList.remove("active")); 
    b.classList.add("active"); 
    redraw();
    autoSave();
  })
});

drawModeBtn.onclick=()=>{ 
  mode="draw"; 
  updateBrushPreview(); 
  updateModeButtons();
};

eraserBtn.onclick=()=>{ 
  mode="erase"; 
  updateBrushPreview(); 
  updateModeButtons();
};

// Grid toggle
gridToggleBtn.onclick=()=>{ 
  showGrid = !showGrid;
  updateModeButtons();
  redraw();
  autoSave();
};

// Clear storage button
clearStorageBtn.onclick=clearLocalStorage;

// Mouse events
canvas.addEventListener("mousedown", e=>{
  if(e.button===1||e.shiftKey){ 
    isPanning=true; 
    lastMouse={x:e.clientX,y:e.clientY}; 
    return; 
  }
  if(e.button===0){
    isDrawing=true; 
    const world=screenToWorld(e.clientX,e.clientY);
    
    if(mode === "draw") {
      currentStroke={
        points:[world], 
        width:currentSize/scale, 
        color:currentColor, 
        isEraser:false
      };
    } else {
      currentStroke={
        points:[world], 
        width:currentSize/scale, 
        isEraser:true
      };
    }
    
    strokes.push(currentStroke);
    redraw();
  }
});

canvas.addEventListener("mousemove", e=>{
  if(isPanning){ 
    offsetX+=e.clientX-lastMouse.x; 
    offsetY+=e.clientY-lastMouse.y; 
    lastMouse={x:e.clientX,y:e.clientY}; 
    redraw(); 
    return; 
  }
  if(isDrawing && currentStroke){
    const world=screenToWorld(e.clientX,e.clientY);
    currentStroke.points.push(world);
    redraw();
  }
});

canvas.addEventListener("mouseup", e=>{
  if(isPanning){ 
    isPanning=false;
    autoSave();
    return; 
  }
  if(isDrawing){ 
    isDrawing=false;
    if(currentStroke) {
      const strokeToSave = {...currentStroke, points: [...currentStroke.points]};
      undoStack.push({ 
        undo:()=>{ 
          strokes.pop(); 
          redraw(); 
        }, 
        redo:()=>{ 
          strokes.push(strokeToSave); 
          redraw(); 
        } 
      });
      redoStack.length=0;
      autoSave();
    }
    currentStroke = null;
  }
});

canvas.addEventListener("wheel", e=>{
  e.preventDefault();
  const mouse={x:e.clientX,y:e.clientY};
  const worldBefore=screenToWorld(mouse.x, mouse.y);
  const factor=e.deltaY<0?1.1:1/1.1;
  scale*=factor; 
  scale=Math.min(Math.max(scale,0.05),50);
  const worldAfter=screenToWorld(mouse.x, mouse.y);
  offsetX+=(worldAfter.x-worldBefore.x)*scale;
  offsetY+=(worldAfter.y-worldBefore.y)*scale;
  redraw();
  autoSave();
},{passive:false});

window.addEventListener("resize", ()=>{ 
  width=window.innerWidth; 
  height=window.innerHeight; 
  canvas.width=width; 
  canvas.height=height; 
  redraw(); 
});

// Undo/Redo
function undo(){ 
  if(undoStack.length>0){ 
    const cmd=undoStack.pop(); 
    cmd.undo(); 
    redoStack.push(cmd);
    autoSave();
  } 
}
function redo(){ 
  if(redoStack.length>0){ 
    const cmd=redoStack.pop(); 
    cmd.redo(); 
    undoStack.push(cmd);
    autoSave();
  } 
}

undoBtn.onclick=undo; 
redoBtn.onclick=redo;

function exportPNG(){ 
  exportPopup.style.display = "flex";
}
exportBtn.onclick=exportPNG;

// Clear confirmation
const confirmPopup=document.getElementById("confirmPopup");
const yesBtn=document.getElementById("confirmYes");
const noBtn=document.getElementById("confirmNo");

clearBtn.onclick=()=>{ 
  confirmPopup.classList.add("show"); 
};

yesBtn.onclick=()=>{ 
  strokes=[]; 
  undoStack=[]; 
  redoStack=[]; 
  redraw(); 
  confirmPopup.classList.remove("show");
  autoSave();
};

noBtn.onclick=()=>{ 
  confirmPopup.classList.remove("show"); 
};

// Toolbar toggle
const toggleBtn=document.getElementById("toggleToolbar");
const toolbar=document.getElementById("toolbar");
let toolbarVisible=true;

toggleBtn.onclick=()=>{ 
  toolbarVisible=!toolbarVisible; 
  if(toolbarVisible) {
    toolbar.classList.remove("hidden");
  } else {
    toolbar.classList.add("hidden");
  }
};

// Close popup with Escape key
window.addEventListener("keydown", e => {
  if(e.key === "Escape") {
    if(howToUsePopup.style.display !== "none") {
      howToUsePopup.style.display = "none";
    }
    if(exportPopup.style.display === "flex") {
      exportPopup.style.display = "none";
    }
  }
  if(e.ctrlKey && (e.key==="z"||e.key==="Z")){ 
    e.preventDefault(); 
    if(e.shiftKey) {
      redo();
    } else {
      undo(); 
    }
  } 
});

// ============= INITIALIZATION =============

// Load saved drawing on startup
const loaded = loadFromLocalStorage();

// Initialize UI
updateBrushPreview();
updateModeButtons();
document.querySelector('.color[data-color="#ffffff"]').classList.add("active");
redraw();

if(loaded) {
  console.log('Previous drawing restored!');
  // Show a brief notification
  saveIndicator.textContent = '‚úÖ –í—ä–∑—Å—Ç–∞–Ω–æ–≤–µ–Ω–æ!';
  saveIndicator.classList.add('show');
  setTimeout(() => {
    saveIndicator.classList.remove('show');
    saveIndicator.textContent = 'üíæ –ó–∞–ø–∞–∑–µ–Ω–æ!';
  }, 2000);
}
</script>
</body>
</html>